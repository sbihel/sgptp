\documentclass{article}

\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}

\usepackage{fullpage}

\title{SGP -- TP4\\Prise en main de Nachos}
\author{Louis Béziaud \and Simon Bihel}

\begin{document}

\maketitle

\section{Mécanisme d'appel système}
Lorsqu'on exécute la commande {\tt ./nachos test/hello} on fourni à la fonction {\tt main} de nachos l'exécutable à exécuter. Cette fonction {\tt main} boot la machine et le système puis crée un processus (pour la mémoire) et un thread (pour l'exécution) pour l'exécutable. Ensuite on fait finir le main thread et quand le dernier thread finira le système sera shutdown {\bf par qui? cpas clair j'ai l'impression que c'est pas encore implémenté}. Quand c'est au tour du thread de notre exécutable, on appel la fonction {\tt n\_printf} qui va calculer la chaine de caractères à afficher et ensuite la passer au driver de la console.

\section{Gestion de threads et de processus}

\begin{enumerate}
\item Lors d'un changement de contexte entre deux threads, il est nécessaire de sauvegarder les contextes utilisateur (avec {\tt SaveProcessorState()}) et noyau (avec {\tt SaveSimulatorState()}). Le contexte du thread est constitué de l'état des registres de la machine MIPS (\texttt{thread\_context.int\_registers} et \texttt{thread\_context.float\_registers}), celui du simulateur regroupe les variables d'état du simulateur (\texttt{simulator\_context.buf}) et le pointeur de pile (\texttt{simulator\_context.stackPointer}). % p. 19
\item La variable {\tt readyList} est utilisée pour mémoriser les threads prêts à s'exécuter. Le thread actif n'appartient pas à cette liste. Celui-ci est accessible par le pointeur {\tt g\_current\_thread}.
\item La variable {\tt g\_alive} liste les threads existants. {\tt readyList} est donc inclue dans {\tt g\_alive} avec en plus les threads actifs, les bloqués et ceux qui ont terminé.
\item Les threads se chargent de leurs allocations/desallocations. Comme les threads se mettent eux-mêmes dans certaines listes et ont besoin d'être associés à un processus pour avoir une zone d'adressage ça ne peut pas être fait pas quelqu'un d'autre.
\item Un thread bloqué sur un sémaphore se trouve dans {\tt g\_alive} et la {\tt queue} du sémaphore en question (mais pas dans {\tt readyList}).
\item ... You disable interrupts ??
\item {\tt SwitchTo} permet de changer de thread actif. Bah c'est pour stocker le contexte. Bah 'y en a une qui sauvegarde le contexte (les signaux bloqués, la zone où se trouve la stack, les registres sauvegardés, le contexte à restaurer quand le thread aura fini, la position de la stack et sa taille) du simulateur et l'autre qui le remet. Bah sauvegarder/restaurer le contexte du thread (les registres d'entiers, de flottants et de conditions);
\item C'est pour vérifier que les objets fourni par l'utilisateur au système sont du bon type. Ça permet de savoir ce qui ne va pas et arrêter le programme utilisateur plutôt que le programme du système soit cassé parce qu'il a lu un mauvais espace mémoire et du coup c'est tout le système qui plante.
\end{enumerate}

\section{Environnement de développement}

\begin{enumerate}
\item {\tt gdb} est utilisable, il y aussi des statistiques pour les processus.
\item {\tt gdb} permet de suivre l'exécution du programme. Donc typiquement pour des fonction ``not fully implemented'' ça va permettre de voir si des variables ont bien été changées, si le contexte a bien été restauré, {\it etc}.
\item L'exécution des programmes utilisateurs est encadrées par le noyau donc oui (?).
\end{enumerate}

\end{document}
